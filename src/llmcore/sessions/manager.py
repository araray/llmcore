# src/llmcore/sessions/manager.py
"""
Session Management for LLMCore.

This module defines the SessionManager class, responsible for handling
the lifecycle and state of ChatSession objects, including loading from
and saving to a configured storage backend provided by StorageManager.
"""

import logging
from typing import Optional

from ..models import ChatSession, Message, Role
from ..storage.base_session import BaseSessionStorage # Keep BaseSessionStorage for type hint
from ..exceptions import SessionNotFoundError, SessionStorageError, LLMCoreError

logger = logging.getLogger(__name__)


class SessionManager:
    """
    Manages ChatSession objects, interacting with a storage backend.

    Coordinates loading, creating, and saving conversation sessions using
    the storage instance provided during initialization.
    """

    def __init__(self, storage: BaseSessionStorage):
        """
        Initializes the SessionManager.

        Args:
            storage: An initialized instance of a BaseSessionStorage backend
                     (obtained from StorageManager).
        """
        if not storage:
            # This check ensures storage is provided, preventing None errors later.
            # LLMCore.create should guarantee storage is initialized before SessionManager.
            logger.error("SessionManager initialized without a valid storage backend.")
            raise LLMCoreError("SessionManager requires a valid storage backend instance.")
        self._storage = storage # Store the provided storage instance
        logger.debug("SessionManager initialized with storage backend: %s", type(storage).__name__)

    async def load_or_create_session(
        self,
        session_id: Optional[str] = None,
        system_message: Optional[str] = None
    ) -> ChatSession:
        """
        Loads an existing session or creates a new one.

        If session_id is provided:
          - Tries to load the session from storage.
          - If not found, creates a *new persistent session* with that ID.
        If session_id is None:
          - Creates a new, temporary (in-memory) session.
        If system_message is provided *and* a *new* session is created (either
        temporary or persistent):
          - The system message is added as the first message.

        Args:
            session_id: The ID of the session to load or create. If None,
                        a temporary session is created.
            system_message: An optional system message to add if a new session
                            is created.

        Returns:
            The loaded or newly created ChatSession object.

        Raises:
            SessionStorageError: If there's an error interacting with storage during loading.
        """
        if session_id:
            logger.debug(f"Attempting to load or create session with ID: {session_id}")
            try:
                # Use the injected storage backend instance
                session = await self._storage.get_session(session_id)
                if session:
                    logger.info(f"Loaded existing session: {session_id}")
                    # Note: We currently don't modify an existing session's system message here.
                    # If a system message is provided for an existing session, it might be ignored
                    # or handled by the ContextManager depending on strategy.
                    if system_message:
                         logger.warning(f"System message provided for existing session '{session_id}'. It might be ignored depending on context strategy.")
                    return session
                else:
                    # Session ID was provided, but not found in storage -> Create new persistent session
                    logger.info(f"Session ID '{session_id}' not found. Creating new persistent session.")
                    new_session = ChatSession(id=session_id) # Create with the specified ID
                    if system_message:
                        logger.debug(f"Adding system message to new persistent session '{session_id}'.")
                        new_session.add_message(message_content=system_message, role=Role.SYSTEM)
                    return new_session

            except SessionStorageError as e:
                # Log and re-raise storage errors encountered during the load attempt
                logger.error(f"Storage error while trying to load session '{session_id}': {e}")
                raise
            except Exception as e:
                # Catch other potential errors during loading/creation
                logger.error(f"Unexpected error loading or creating session '{session_id}': {e}", exc_info=True)
                raise SessionStorageError(f"Failed to load or create session '{session_id}': {e}")

        # If session_id is None, create a new temporary session
        logger.info("Creating new temporary session (session_id is None).")
        # The ID will be generated by ChatSession's default_factory
        new_temporary_session = ChatSession() # ID generated automatically
        # Assign a temporary prefix to distinguish if needed, though not strictly necessary
        # new_temporary_session.id = f"temp_{new_temporary_session.id}"
        if system_message:
            logger.debug("Adding system message to new temporary session.")
            # Use the add_message helper method from ChatSession
            new_temporary_session.add_message(message_content=system_message, role=Role.SYSTEM)

        return new_temporary_session


    async def save_session(self, session: ChatSession) -> None:
        """
        Saves a session to the configured storage backend.

        Args:
            session: The ChatSession object to save.

        Raises:
            SessionStorageError: If there's an error saving the session.
        """
        # Avoid saving sessions that were intended to be temporary (if we added a prefix)
        # if session.id.startswith("temp_"):
        #     logger.debug(f"Skipping save for temporary session: {session.id}")
        #     return

        logger.debug(f"Attempting to save session: {session.id}")
        try:
            # Use the injected storage backend instance
            await self._storage.save_session(session)
            logger.info(f"Session '{session.id}' saved successfully.")
        except SessionStorageError as e:
            logger.error(f"Storage error while saving session '{session.id}': {e}")
            raise # Re-raise storage errors
        except Exception as e:
            logger.error(f"Unexpected error saving session '{session.id}': {e}", exc_info=True)
            raise SessionStorageError(f"Failed to save session '{session.id}': {e}")
